"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = __importDefault(require("immutable"));
const inherits = require("util").inherits;
const styles_1 = __importDefault(require("../constants/styles"));
const isBlock_1 = __importDefault(require("../utils/isBlock"));
const isEntity_1 = __importDefault(require("../utils/isEntity"));
const isStyle_1 = __importDefault(require("../utils/isStyle"));
const TokenRecord = immutable_1.default.Record({
    // Type of token
    type: String(),
    // Metadata for this token
    data: immutable_1.default.Map(),
    // Inner text of this token (for inline tokens)
    text: null,
    // Original raw content of this token
    // Can be use for annotating
    raw: String(),
    // List of children tokens (for block tokens)
    tokens: immutable_1.default.List(),
});
function Token(def) {
    if (!(this instanceof Token)) {
        // @ts-ignore
        return new Token(def);
    }
    TokenRecord.call(this, {
        type: def.type,
        data: immutable_1.default.Map(def.data),
        text: def.text,
        raw: def.raw,
        tokens: immutable_1.default.List(def.tokens),
    });
}
inherits(Token, TokenRecord);
// ---- GETTERS ----
Token.prototype.getType = function () {
    return this.get("type");
};
Token.prototype.getData = function () {
    return this.get("data");
};
Token.prototype.getText = function () {
    return this.get("text");
};
Token.prototype.getRaw = function () {
    return this.get("raw");
};
Token.prototype.getTokens = function () {
    return this.get("tokens");
};
/**
 * Return true if is a block token
 * @return {Boolean}
 */
Token.prototype.isBlock = function () {
    return isBlock_1.default(this);
};
/**
 * Return true if is an inline token
 * @return {Boolean}
 */
Token.prototype.isInline = function () {
    return !this.isBlock();
};
/**
 * Return true if is an inline style
 * @return {Boolean}
 */
Token.prototype.isStyle = function () {
    return isStyle_1.default(this);
};
/**
 * Return true if is an inline entity
 * @return {Boolean}
 */
Token.prototype.isEntity = function () {
    return isEntity_1.default(this);
};
/**
 * Merge this token with another one
 * @param {Token} token
 * @return {Token}
 */
Token.prototype.mergeWith = function (token) {
    return this.merge({
        type: token.getType(),
        text: this.getText() + token.getText(),
        raw: this.getRaw() + token.getRaw(),
        data: this.getData().merge(token.getData()),
        tokens: this.getTokens().concat(token.getTokens()),
    });
};
/**
 * Push an inner token
 * @param {Token} token
 * @return {Token}
 */
Token.prototype.pushToken = function (token) {
    return this.merge({
        tokens: this.getTokens().push(token),
    });
};
/**
 * Update data of the token
 * @param {Object|Map}
 * @return {Token}
 */
Token.prototype.setData = function (data) {
    return this.set("data", immutable_1.default.Map(data));
};
/**
 * Return plain text of a token merged with its children.
 * @return {String}
 */
Token.prototype.getAsPlainText = function () {
    const tokens = this.getTokens();
    if (tokens.size === 0) {
        return this.getText() || "";
    }
    return tokens.reduce((text, tok) => {
        return text + tok.getAsPlainText();
    }, "");
};
// ---- STATICS ----
/**
 * Create a token
 * @param {Object} tok
 * @return {Token}
 */
Token.create = function (type, tok) {
    tok = tok || {};
    let text = tok.text || "";
    const tokens = immutable_1.default.List(tok.tokens || []);
    const data = immutable_1.default.Map(tok.data || {});
    if (tokens.size > 0) {
        text = undefined;
    }
    // @ts-ignore
    return new Token({
        type: type,
        text: text,
        raw: tok.raw || "",
        tokens: tokens,
        data: data,
    });
};
/**
 * Create a token for an inline text
 * @param {String} text
 * @return {Token}
 */
Token.createText = function (text) {
    return Token.create(styles_1.default.TEXT, {
        text: text,
        raw: text,
    });
};
exports.default = Token;
