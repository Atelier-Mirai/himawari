"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = __importDefault(require("immutable"));
const content_1 = __importDefault(require("../models/content"));
/**
 * Walk throught the children tokens tree, and
 * map each token using a transformation
 *
 * The transformation iterator can return a list, a new token or undefined.
 *
 * @param {Token|Content} base
 * @param {Function(token, depth)} iter
 * @param {Number} depth
 * @return {Token}
 */
function transformToken(base, iter, depth = 0) {
    const tokens = base.getTokens();
    const newTokens = transformTokens(tokens, iter);
    base = base.set("tokens", newTokens);
    return base instanceof content_1.default ? base : iter(base, depth);
}
/**
 * Transform a list of tokens
 * @param {List<Token>} tokens
 * @param {Function} iter
 * @param {Number} depth
 * @return {List<Token>}
 */
function transformTokens(tokens, iter) {
    return tokens.reduce((list, token) => {
        const result = transform(token, iter);
        if (immutable_1.default.List.isList(result)) {
            return list.concat(result);
        }
        else if (result) {
            return list.push(result);
        }
        return list;
    }, immutable_1.default.List());
}
/**
 * Transform that works on token or list of tokens
 * @param  {Token|List<Token>|Content} base
 * @param  {Function} iter
 * @return {Token|List<Token>|Content}
 */
function transform(base, iter) {
    if (immutable_1.default.List.isList(base)) {
        return transformTokens(base, iter);
    }
    else {
        return transformToken(base, iter);
    }
}
exports.default = transform;
